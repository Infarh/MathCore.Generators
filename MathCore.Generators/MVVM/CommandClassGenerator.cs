using System.Text;

using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MathCore.Generators.MVVM;

[Generator]
public class CommandClassGenerator : ISourceGenerator
{
    private class SyntaxReceiver : ISyntaxReceiver
    {
        private bool _CommandAttributeExists;

        public bool CommandAttributeExists => _CommandAttributeExists;

        public void OnVisitSyntaxNode(SyntaxNode Node)
        {
            if(_CommandAttributeExists || Node is not MethodDeclarationSyntax { AttributeLists: { Count: > 0 } method_attributes_list } method_node || method_node.IsStatic())
                return;

            foreach (var method_attributes in method_attributes_list)
                foreach (var attributes in method_attributes.Attributes)
                    if (attributes.Name.ToFullString() is "Command" or "CommandAttribute")
                    {
                        _CommandAttributeExists = true;
                        return;
                    }
        }
    }

    public void Initialize(GeneratorInitializationContext context) => context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver { CommandAttributeExists: true }) 
            return;

        var can_execute_changed_event = context.Compilation.ReferencedAssemblyNames.Any(static asm => asm.Name == "PresentationCore") 
            ? """
        public event EventHandler? CanExecuteChanged
        {
            add => CommandManager.RequerySuggested += value;
            remove => CommandManager.RequerySuggested -= value;
        }
"""
        : """
        public event EventHandler? CanExecuteChanged;

        public virtual void OnCanExecuteChanged(EventArgs? e = null) => CanExecuteChanged?.Invoke(this, e ?? EventArgs.Empty);
""";

        const string name_space = "MathCore.Generated.MVVM";

        context.AddSource("MVVM.Command.g.cs", SourceText.From(
$$"""
// Autogenerated source code at {{DateTime.Now}}
#nullable enable
using System;
using System.Windows.Input;

namespace {{name_space}}.Commands.Base
{
    public abstract class Command : ICommand
    {
{{can_execute_changed_event}}

        bool ICommand.CanExecute(object? parameter) => CanExecute(parameter);

        void ICommand.Execute(object? parameter)
        {
            if(!CanExecute(parameter)) return;
            Execute(parameter);
        }

        protected virtual bool CanExecute(object? parameter) => true;

        protected abstract void Execute(object? parameter);
    }
}

namespace {{name_space}}.Commands
{
    public class LambdaCommand : Base.Command
    {
        private readonly Action<object?> _Execute;

        private readonly Func<object?, bool>? _CanExecute;

        public LambdaCommand(Action Execute, Func<bool>? CanExecute = null)
            : this(_ => Execute(), CanExecute is null ? null : _ => CanExecute())
        {

        }

        public LambdaCommand(Action<object?> Execute, Func<object?, bool>? CanExecute = null)
        {
            _Execute = Execute;
            _CanExecute = CanExecute;
        }

        protected override bool CanExecute(object? parameter) => base.CanExecute(parameter) && _CanExecute?.Invoke(parameter) == true;

        protected override void Execute(object? parameter) => _Execute(parameter);
    }
}
""", Encoding.UTF8));

    }
}