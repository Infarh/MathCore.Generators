using System.Drawing;
using System.Text;

using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MathCore.Generators.MVVM;

[Generator]
public class CommandClassGenerator : ISourceGenerator
{
    private class SyntaxReceiver : ISyntaxReceiver
    {
        private bool _CommandAttributeExists;

        public bool CommandAttributeExists => _CommandAttributeExists;

        public void OnVisitSyntaxNode(SyntaxNode Node)
        {
            if(_CommandAttributeExists || Node is not MethodDeclarationSyntax { AttributeLists: { Count: > 0 } method_attributes_list } method_node || method_node.IsStatic())
                return;

            foreach (var method_attributes in method_attributes_list)
                foreach (var attributes in method_attributes.Attributes)
                    if (attributes.Name.ToFullString() is "Command" or "CommandAttribute")
                    {
                        _CommandAttributeExists = true;
                        return;
                    }
        }
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if(context.SyntaxReceiver is not SyntaxReceiver { CommandAttributeExists: true } receiver) 
            return;

        const string NameSpace = "MathCore.Generated.MVVM";

        context.AddSource("MVVM.Command.g.cs", SourceText.From(
$$"""
// Autogenerated source code at {{DateTime.Now}}
#nullable enable
using System;
using System.Windows.Input;

namespace {{NameSpace}}.Commands.Base
{
    public abstract class Command : ICommand
    {
        public event EventHandler? CanExecuteChanged;

        protected virtual void OnCanExecuteChanged(EventArgs e) => CanExecuteChanged?.Invoke(this, e);

        bool ICommand.CanExecute(object? parameter) => CanExecute(parameter);

        void ICommand.Execute(object? parameter)
        {
            if(!CanExecute(parameter)) return;
            Execute(parameter);
        }

        protected virtual bool CanExecute(object? parameter) => true;

        protected abstract void Execute(object? parameter);
    }
}

namespace {{NameSpace}}.Commands
{
    public class LambdaCommand : Base.Command
    {
        private readonly Action<object?> _Execute;

        private readonly Func<object?, bool>? _CanExecute;

        public LambdaCommand(Action Execute, Func<bool>? CanExecute = null) 
            : this(_ => Execute(), CanExecute is null ? null : _ => CanExecute()) 
        {

        }

        public LambdaCommand(Action<object?> Execute, Func<object?, bool>? CanExecute = null)
        {
            _Execute = Execute;
            _CanExecute = CanExecute;
        }

        protected override bool CanExecute(object? parameter) => base.CanExecute(parameter) && _CanExecute?.Invoke(parameter) == true;

        protected override void Execute(object? parameter) => _Execute(parameter);
    }
}
""", Encoding.UTF8));

    }
}